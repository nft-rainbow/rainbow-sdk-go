/*
Rainbow-API

The responses of the open api in swagger focus on the data field rather than the code and the message fields

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package rainbowsdk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type TBAAPI interface {

	/*
	TBACollectionEndpoint Create a new TBA collection

	Create a new token bound account collection based on provided details.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiTBACollectionEndpointRequest
	*/
	TBACollectionEndpoint(ctx context.Context) ApiTBACollectionEndpointRequest

	// TBACollectionEndpointExecute executes the request
	//  @return ModelsTokenBoundAccountCollectionQueryResult
	TBACollectionEndpointExecute(r ApiTBACollectionEndpointRequest) (*ModelsTokenBoundAccountCollectionQueryResult, *http.Response, error)

	/*
	TBACollectionMetaInfoModificationEndpoint Modify meta information of a TBA collection

	Modify the name and description of a TBA collection based on the provided details

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param collectionName Name of the TBA collection to be modified
	@return ApiTBACollectionMetaInfoModificationEndpointRequest
	*/
	TBACollectionMetaInfoModificationEndpoint(ctx context.Context, collectionName string) ApiTBACollectionMetaInfoModificationEndpointRequest

	// TBACollectionMetaInfoModificationEndpointExecute executes the request
	//  @return map[string]map[string]interface{}
	TBACollectionMetaInfoModificationEndpointExecute(r ApiTBACollectionMetaInfoModificationEndpointRequest) (map[string]map[string]interface{}, *http.Response, error)

	/*
	TBACollectionNewItemsEndpoint Add new items to a TBA collection

	Add new accounts to a specified TBA collection based on the provided details. This api will ignore the error that the account is already in the collection. If any other error occurs, none of the specified tbas will be added to the collection.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param collectionName Name of the TBA collection to add items to
	@return ApiTBACollectionNewItemsEndpointRequest
	*/
	TBACollectionNewItemsEndpoint(ctx context.Context, collectionName string) ApiTBACollectionNewItemsEndpointRequest

	// TBACollectionNewItemsEndpointExecute executes the request
	//  @return map[string]map[string]interface{}
	TBACollectionNewItemsEndpointExecute(r ApiTBACollectionNewItemsEndpointRequest) (map[string]map[string]interface{}, *http.Response, error)

	/*
	TBACollectionQueryEndpoint Query token bound account (TBA) collections

	Query TBA collections based on chain, and collection name

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiTBACollectionQueryEndpointRequest
	*/
	TBACollectionQueryEndpoint(ctx context.Context) ApiTBACollectionQueryEndpointRequest

	// TBACollectionQueryEndpointExecute executes the request
	//  @return ModelsTokenBoundAccountCollectionQueryResult
	TBACollectionQueryEndpointExecute(r ApiTBACollectionQueryEndpointRequest) (*ModelsTokenBoundAccountCollectionQueryResult, *http.Response, error)

	/*
	TBACollectionRemoveItemsEndpoint Remove items from a TBA collection

	Remove specified accounts from a TBA collection based on the provided details. This api will ignore the error if the specified item is not in the collection. If any other error occurs, none of the specified items will be deleted.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param collectionName Name of the TBA collection to remove items from
	@return ApiTBACollectionRemoveItemsEndpointRequest
	*/
	TBACollectionRemoveItemsEndpoint(ctx context.Context, collectionName string) ApiTBACollectionRemoveItemsEndpointRequest

	// TBACollectionRemoveItemsEndpointExecute executes the request
	//  @return map[string]map[string]interface{}
	TBACollectionRemoveItemsEndpointExecute(r ApiTBACollectionRemoveItemsEndpointRequest) (map[string]map[string]interface{}, *http.Response, error)

	/*
	TBACreationEndpoint Create a new token bound account (TBA)

	Create a new token bound account based on provided parameters.  Can optionally specify which collection to add. Will fail if the tba is already created or in the queue

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiTBACreationEndpointRequest
	*/
	TBACreationEndpoint(ctx context.Context) ApiTBACreationEndpointRequest

	// TBACreationEndpointExecute executes the request
	//  @return ModelsTBACreationTask
	TBACreationEndpointExecute(r ApiTBACreationEndpointRequest) (*ModelsTBACreationTask, *http.Response, error)

	/*
	TBAQueryEndpoint Get all token bound accounts on chain

	Get token bound accounts based on contract, token_id, implementation, chain type, and chain id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiTBAQueryEndpointRequest
	*/
	TBAQueryEndpoint(ctx context.Context) ApiTBAQueryEndpointRequest

	// TBAQueryEndpointExecute executes the request
	//  @return ModelsTokenBoundAccountQueryResult
	TBAQueryEndpointExecute(r ApiTBAQueryEndpointRequest) (*ModelsTokenBoundAccountQueryResult, *http.Response, error)
}

// TBAAPIService TBAAPI service
type TBAAPIService service

type ApiTBACollectionEndpointRequest struct {
	ctx context.Context
	ApiService TBAAPI
	authorization *string
	createDto *ModelsTBACollectionCreateDto
}

// Bearer Open_JWT
func (r ApiTBACollectionEndpointRequest) Authorization(authorization string) ApiTBACollectionEndpointRequest {
	r.authorization = &authorization
	return r
}

// TBA Collection creation details
func (r ApiTBACollectionEndpointRequest) CreateDto(createDto ModelsTBACollectionCreateDto) ApiTBACollectionEndpointRequest {
	r.createDto = &createDto
	return r
}

func (r ApiTBACollectionEndpointRequest) Execute() (*ModelsTokenBoundAccountCollectionQueryResult, *http.Response, error) {
	return r.ApiService.TBACollectionEndpointExecute(r)
}

/*
TBACollectionEndpoint Create a new TBA collection

Create a new token bound account collection based on provided details.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTBACollectionEndpointRequest
*/
func (a *TBAAPIService) TBACollectionEndpoint(ctx context.Context) ApiTBACollectionEndpointRequest {
	return ApiTBACollectionEndpointRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelsTokenBoundAccountCollectionQueryResult
func (a *TBAAPIService) TBACollectionEndpointExecute(r ApiTBACollectionEndpointRequest) (*ModelsTokenBoundAccountCollectionQueryResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelsTokenBoundAccountCollectionQueryResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TBAAPIService.TBACollectionEndpoint")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/tba/collections"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.createDto == nil {
		return localVarReturnValue, nil, reportError("createDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	// body params
	localVarPostBody = r.createDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RainbowErrorsRainbowErrorDetailInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RainbowErrorsRainbowErrorDetailInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 599 {
			var v RainbowErrorsRainbowErrorDetailInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTBACollectionMetaInfoModificationEndpointRequest struct {
	ctx context.Context
	ApiService TBAAPI
	authorization *string
	collectionName string
	modifyDto *ModelsTBACollectionModifyDto
}

// Bearer Open_JWT
func (r ApiTBACollectionMetaInfoModificationEndpointRequest) Authorization(authorization string) ApiTBACollectionMetaInfoModificationEndpointRequest {
	r.authorization = &authorization
	return r
}

// Modification details
func (r ApiTBACollectionMetaInfoModificationEndpointRequest) ModifyDto(modifyDto ModelsTBACollectionModifyDto) ApiTBACollectionMetaInfoModificationEndpointRequest {
	r.modifyDto = &modifyDto
	return r
}

func (r ApiTBACollectionMetaInfoModificationEndpointRequest) Execute() (map[string]map[string]interface{}, *http.Response, error) {
	return r.ApiService.TBACollectionMetaInfoModificationEndpointExecute(r)
}

/*
TBACollectionMetaInfoModificationEndpoint Modify meta information of a TBA collection

Modify the name and description of a TBA collection based on the provided details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param collectionName Name of the TBA collection to be modified
 @return ApiTBACollectionMetaInfoModificationEndpointRequest
*/
func (a *TBAAPIService) TBACollectionMetaInfoModificationEndpoint(ctx context.Context, collectionName string) ApiTBACollectionMetaInfoModificationEndpointRequest {
	return ApiTBACollectionMetaInfoModificationEndpointRequest{
		ApiService: a,
		ctx: ctx,
		collectionName: collectionName,
	}
}

// Execute executes the request
//  @return map[string]map[string]interface{}
func (a *TBAAPIService) TBACollectionMetaInfoModificationEndpointExecute(r ApiTBACollectionMetaInfoModificationEndpointRequest) (map[string]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TBAAPIService.TBACollectionMetaInfoModificationEndpoint")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/tba/collections/{collection_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"collection_name"+"}", url.PathEscape(parameterValueToString(r.collectionName, "collectionName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.modifyDto == nil {
		return localVarReturnValue, nil, reportError("modifyDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	// body params
	localVarPostBody = r.modifyDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RainbowErrorsRainbowErrorDetailInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RainbowErrorsRainbowErrorDetailInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 599 {
			var v RainbowErrorsRainbowErrorDetailInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTBACollectionNewItemsEndpointRequest struct {
	ctx context.Context
	ApiService TBAAPI
	authorization *string
	collectionName string
	itemsDto *ModelsTBACollectionItemsDto
}

// Bearer Open_JWT
func (r ApiTBACollectionNewItemsEndpointRequest) Authorization(authorization string) ApiTBACollectionNewItemsEndpointRequest {
	r.authorization = &authorization
	return r
}

// Details of the accounts to be added
func (r ApiTBACollectionNewItemsEndpointRequest) ItemsDto(itemsDto ModelsTBACollectionItemsDto) ApiTBACollectionNewItemsEndpointRequest {
	r.itemsDto = &itemsDto
	return r
}

func (r ApiTBACollectionNewItemsEndpointRequest) Execute() (map[string]map[string]interface{}, *http.Response, error) {
	return r.ApiService.TBACollectionNewItemsEndpointExecute(r)
}

/*
TBACollectionNewItemsEndpoint Add new items to a TBA collection

Add new accounts to a specified TBA collection based on the provided details. This api will ignore the error that the account is already in the collection. If any other error occurs, none of the specified tbas will be added to the collection.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param collectionName Name of the TBA collection to add items to
 @return ApiTBACollectionNewItemsEndpointRequest
*/
func (a *TBAAPIService) TBACollectionNewItemsEndpoint(ctx context.Context, collectionName string) ApiTBACollectionNewItemsEndpointRequest {
	return ApiTBACollectionNewItemsEndpointRequest{
		ApiService: a,
		ctx: ctx,
		collectionName: collectionName,
	}
}

// Execute executes the request
//  @return map[string]map[string]interface{}
func (a *TBAAPIService) TBACollectionNewItemsEndpointExecute(r ApiTBACollectionNewItemsEndpointRequest) (map[string]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TBAAPIService.TBACollectionNewItemsEndpoint")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/tba/collections/{collection_name}/items"
	localVarPath = strings.Replace(localVarPath, "{"+"collection_name"+"}", url.PathEscape(parameterValueToString(r.collectionName, "collectionName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.itemsDto == nil {
		return localVarReturnValue, nil, reportError("itemsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	// body params
	localVarPostBody = r.itemsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RainbowErrorsRainbowErrorDetailInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RainbowErrorsRainbowErrorDetailInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 599 {
			var v RainbowErrorsRainbowErrorDetailInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTBACollectionQueryEndpointRequest struct {
	ctx context.Context
	ApiService TBAAPI
	authorization *string
	chain *string
	name *string
	page *int32
	limit *int32
}

// Bearer Open_JWT
func (r ApiTBACollectionQueryEndpointRequest) Authorization(authorization string) ApiTBACollectionQueryEndpointRequest {
	r.authorization = &authorization
	return r
}

// The chain type. The types include &#x60;conflux&#x60; and &#x60;conflux_test&#x60;
func (r ApiTBACollectionQueryEndpointRequest) Chain(chain string) ApiTBACollectionQueryEndpointRequest {
	r.chain = &chain
	return r
}

// Collection name
func (r ApiTBACollectionQueryEndpointRequest) Name(name string) ApiTBACollectionQueryEndpointRequest {
	r.name = &name
	return r
}

// Page number
func (r ApiTBACollectionQueryEndpointRequest) Page(page int32) ApiTBACollectionQueryEndpointRequest {
	r.page = &page
	return r
}

// Limit per page
func (r ApiTBACollectionQueryEndpointRequest) Limit(limit int32) ApiTBACollectionQueryEndpointRequest {
	r.limit = &limit
	return r
}

func (r ApiTBACollectionQueryEndpointRequest) Execute() (*ModelsTokenBoundAccountCollectionQueryResult, *http.Response, error) {
	return r.ApiService.TBACollectionQueryEndpointExecute(r)
}

/*
TBACollectionQueryEndpoint Query token bound account (TBA) collections

Query TBA collections based on chain, and collection name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTBACollectionQueryEndpointRequest
*/
func (a *TBAAPIService) TBACollectionQueryEndpoint(ctx context.Context) ApiTBACollectionQueryEndpointRequest {
	return ApiTBACollectionQueryEndpointRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelsTokenBoundAccountCollectionQueryResult
func (a *TBAAPIService) TBACollectionQueryEndpointExecute(r ApiTBACollectionQueryEndpointRequest) (*ModelsTokenBoundAccountCollectionQueryResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelsTokenBoundAccountCollectionQueryResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TBAAPIService.TBACollectionQueryEndpoint")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/tba/collections"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.chain == nil {
		return localVarReturnValue, nil, reportError("chain is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "chain", r.chain, "")
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RainbowErrorsRainbowErrorDetailInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RainbowErrorsRainbowErrorDetailInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 599 {
			var v RainbowErrorsRainbowErrorDetailInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTBACollectionRemoveItemsEndpointRequest struct {
	ctx context.Context
	ApiService TBAAPI
	authorization *string
	collectionName string
	itemsDto *ModelsTBACollectionItemsDto
}

// Bearer Open_JWT
func (r ApiTBACollectionRemoveItemsEndpointRequest) Authorization(authorization string) ApiTBACollectionRemoveItemsEndpointRequest {
	r.authorization = &authorization
	return r
}

// Details of the accounts to be removed
func (r ApiTBACollectionRemoveItemsEndpointRequest) ItemsDto(itemsDto ModelsTBACollectionItemsDto) ApiTBACollectionRemoveItemsEndpointRequest {
	r.itemsDto = &itemsDto
	return r
}

func (r ApiTBACollectionRemoveItemsEndpointRequest) Execute() (map[string]map[string]interface{}, *http.Response, error) {
	return r.ApiService.TBACollectionRemoveItemsEndpointExecute(r)
}

/*
TBACollectionRemoveItemsEndpoint Remove items from a TBA collection

Remove specified accounts from a TBA collection based on the provided details. This api will ignore the error if the specified item is not in the collection. If any other error occurs, none of the specified items will be deleted.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param collectionName Name of the TBA collection to remove items from
 @return ApiTBACollectionRemoveItemsEndpointRequest
*/
func (a *TBAAPIService) TBACollectionRemoveItemsEndpoint(ctx context.Context, collectionName string) ApiTBACollectionRemoveItemsEndpointRequest {
	return ApiTBACollectionRemoveItemsEndpointRequest{
		ApiService: a,
		ctx: ctx,
		collectionName: collectionName,
	}
}

// Execute executes the request
//  @return map[string]map[string]interface{}
func (a *TBAAPIService) TBACollectionRemoveItemsEndpointExecute(r ApiTBACollectionRemoveItemsEndpointRequest) (map[string]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TBAAPIService.TBACollectionRemoveItemsEndpoint")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/tba/collections/{collection_name}/items"
	localVarPath = strings.Replace(localVarPath, "{"+"collection_name"+"}", url.PathEscape(parameterValueToString(r.collectionName, "collectionName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.itemsDto == nil {
		return localVarReturnValue, nil, reportError("itemsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	// body params
	localVarPostBody = r.itemsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RainbowErrorsRainbowErrorDetailInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RainbowErrorsRainbowErrorDetailInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 599 {
			var v RainbowErrorsRainbowErrorDetailInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTBACreationEndpointRequest struct {
	ctx context.Context
	ApiService TBAAPI
	authorization *string
	tbaCreateDto *ModelsTBACreateDto
}

// Bearer Open_JWT
func (r ApiTBACreationEndpointRequest) Authorization(authorization string) ApiTBACreationEndpointRequest {
	r.authorization = &authorization
	return r
}

// Token Bound Account creation details
func (r ApiTBACreationEndpointRequest) TbaCreateDto(tbaCreateDto ModelsTBACreateDto) ApiTBACreationEndpointRequest {
	r.tbaCreateDto = &tbaCreateDto
	return r
}

func (r ApiTBACreationEndpointRequest) Execute() (*ModelsTBACreationTask, *http.Response, error) {
	return r.ApiService.TBACreationEndpointExecute(r)
}

/*
TBACreationEndpoint Create a new token bound account (TBA)

Create a new token bound account based on provided parameters.  Can optionally specify which collection to add. Will fail if the tba is already created or in the queue

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTBACreationEndpointRequest
*/
func (a *TBAAPIService) TBACreationEndpoint(ctx context.Context) ApiTBACreationEndpointRequest {
	return ApiTBACreationEndpointRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelsTBACreationTask
func (a *TBAAPIService) TBACreationEndpointExecute(r ApiTBACreationEndpointRequest) (*ModelsTBACreationTask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelsTBACreationTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TBAAPIService.TBACreationEndpoint")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/tba/accounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.tbaCreateDto == nil {
		return localVarReturnValue, nil, reportError("tbaCreateDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	// body params
	localVarPostBody = r.tbaCreateDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RainbowErrorsRainbowErrorDetailInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RainbowErrorsRainbowErrorDetailInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 599 {
			var v RainbowErrorsRainbowErrorDetailInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTBAQueryEndpointRequest struct {
	ctx context.Context
	ApiService TBAAPI
	authorization *string
	chain *string
	implementation *string
	contract *string
	tokenId *string
	page *int32
	limit *int32
}

// Bearer Open_JWT
func (r ApiTBAQueryEndpointRequest) Authorization(authorization string) ApiTBAQueryEndpointRequest {
	r.authorization = &authorization
	return r
}

// Chain name, should be either conflux or conflux_test
func (r ApiTBAQueryEndpointRequest) Chain(chain string) ApiTBAQueryEndpointRequest {
	r.chain = &chain
	return r
}

// The implementation contract address of the tba. Will throw an error if the implementation is not in whitelist
func (r ApiTBAQueryEndpointRequest) Implementation(implementation string) ApiTBAQueryEndpointRequest {
	r.implementation = &implementation
	return r
}

// Token contract address of the bounded NFT
func (r ApiTBAQueryEndpointRequest) Contract(contract string) ApiTBAQueryEndpointRequest {
	r.contract = &contract
	return r
}

// Token ID
func (r ApiTBAQueryEndpointRequest) TokenId(tokenId string) ApiTBAQueryEndpointRequest {
	r.tokenId = &tokenId
	return r
}

// Page number
func (r ApiTBAQueryEndpointRequest) Page(page int32) ApiTBAQueryEndpointRequest {
	r.page = &page
	return r
}

// Limit per page
func (r ApiTBAQueryEndpointRequest) Limit(limit int32) ApiTBAQueryEndpointRequest {
	r.limit = &limit
	return r
}

func (r ApiTBAQueryEndpointRequest) Execute() (*ModelsTokenBoundAccountQueryResult, *http.Response, error) {
	return r.ApiService.TBAQueryEndpointExecute(r)
}

/*
TBAQueryEndpoint Get all token bound accounts on chain

Get token bound accounts based on contract, token_id, implementation, chain type, and chain id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTBAQueryEndpointRequest
*/
func (a *TBAAPIService) TBAQueryEndpoint(ctx context.Context) ApiTBAQueryEndpointRequest {
	return ApiTBAQueryEndpointRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelsTokenBoundAccountQueryResult
func (a *TBAAPIService) TBAQueryEndpointExecute(r ApiTBAQueryEndpointRequest) (*ModelsTokenBoundAccountQueryResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelsTokenBoundAccountQueryResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TBAAPIService.TBAQueryEndpoint")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/tba/accounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.chain == nil {
		return localVarReturnValue, nil, reportError("chain is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "chain", r.chain, "")
	if r.implementation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "implementation", r.implementation, "")
	}
	if r.contract != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contract", r.contract, "")
	}
	if r.tokenId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "token_id", r.tokenId, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RainbowErrorsRainbowErrorDetailInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RainbowErrorsRainbowErrorDetailInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 599 {
			var v RainbowErrorsRainbowErrorDetailInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
